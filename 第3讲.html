<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第3课：Dockerfile 自动化构建镜像</title>
    
    <!-- 统一样式引用 -->
    <link rel='stylesheet' href='../模板/统一讲义样式模板.css'>
    <!-- 通用工具函数库 -->
    <script src='../模板/js/lecture-utils.js'></script>
</head>
<body>

<!-- ============================================
     侧边栏导航 - 课程目录
     ============================================ -->
<nav class="sidebar">
    <div class="sidebar-nav">
        <h3>课程导航</h3>
        <a class="sidebar-link" href="#intro">👋 课程概览</a>
        
        <!-- Part 1: 回顾与引入 -->
        <h3>Part 1: 知识回顾</h3>
        <a class="sidebar-link sub-link" href="#review">一、Docker 基础回顾</a>
        
        <!-- Part 2: Dockerfile 基础 -->
        <h3>Part 2: Dockerfile 基础</h3>
        <a class="sidebar-link sub-link" href="#dockerfile-intro">二、认识 Dockerfile</a>
        <a class="sidebar-link sub-link" href="#first-dockerfile">三、第一个 Dockerfile</a>
        <a class="sidebar-link sub-link" href="#lab-1">🔬 实验 01</a>
        
        <!-- Part 3: 深入学习 -->
        <h3>Part 3: 指令详解</h3>
        <a class="sidebar-link sub-link" href="#build-details">四、docker build 详解</a>
        <a class="sidebar-link sub-link" href="#dockerfile-commands">五、常用指令实战</a>
        <a class="sidebar-link sub-link" href="#lab-2">🔬 实验 02</a>
        
        <!-- Part 4: 项目实战 -->
        <h3>Part 4: 项目实战</h3>
        <a class="sidebar-link sub-link" href="#mini-project">六、打包个人主页</a>
        <a class="sidebar-link sub-link" href="#image-optimize">七、镜像优化技巧</a>
        <a class="sidebar-link sub-link" href="#troubleshooting">八、常见错误排查</a>
        
        <!-- 总结 -->
        <h3>总结与练习</h3>
        <a class="sidebar-link sub-link" href="#summary">📝 课程小结</a>
    </div>
</nav>


<!-- ============================================
     主内容区域
     ============================================ -->
<main class="content">

    <!-- ============================================
         课程头部 - 概览区域
         ============================================ -->
    <header id="intro">
        <h1>第3课：Dockerfile 自动化构建镜像</h1>
        <p class="intro">上节课我们手动进入容器修改文件，但每次重启容器改动就丢失了。本课将学习使用 Dockerfile 自动化构建镜像，让修改"固化"到镜像里，实现一次编写、随处运行。</p>
        
        <!-- 知识点标签列表 -->
        <div class="pill-list">
            <span class="pill">Dockerfile</span>
            <span class="pill">FROM</span>
            <span class="pill">COPY</span>
            <span class="pill">RUN</span>
            <span class="pill">CMD</span>
            <span class="pill">WORKDIR</span>
            <span class="pill">EXPOSE</span>
            <span class="pill">ENV</span>
            <span class="pill">镜像优化</span>
        </div>
    </header>


    <!-- ============================================
         第一部分：知识回顾
         ============================================ -->
    
    <section id="review">
        <h2>一、知识回顾：Docker 基础</h2>
        
        <div class="note-box">
            <strong>三大核心概念回顾：</strong>
            <ul class="checklist">
                <li><strong>镜像（Image）</strong>：类似"软件安装包"，包含运行环境和程序</li>
                <li><strong>容器（Container）</strong>：镜像运行后的实例，像"正在运行的软件"</li>
                <li><strong>仓库（Registry）</strong>：存放镜像的云端仓库（如 Docker Hub）</li>
            </ul>
        </div>
        
        <h3>1.1 验证命令回顾</h3>
        
        <h4>查看本地镜像</h4>
<pre><code>docker images</code></pre>
        <p>预期输出：</p>
<pre><code>REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
nginx        latest    605c77e624dd   2 weeks ago    141MB
nginx        alpine    8e75cbc5b25c   2 weeks ago    41MB</code></pre>
        
        <h4>查看运行中的容器</h4>
<pre><code>docker ps</code></pre>
        
        <div class="tip-box">
            <span class="tip-title">💡 互动提问</span>
            <ul>
                <li>如果 <code>docker ps</code> 什么都不显示，说明什么？</li>
                <li>镜像和容器的关系，像什么和什么的关系？</li>
            </ul>
        </div>

        <h3>1.2 手动构建镜像：docker commit</h3>
        <p>在学习自动化构建之前，我们先了解如何将现有的容器保存为镜像。这就像是在虚拟机里安装好软件后"打快照"。</p>
        
        <h4>1. 命令格式</h4>
<pre><code>docker commit [选项] &lt;容器ID或名称&gt; &lt;新镜像名&gt;[:标签]</code></pre>
        
        <h4>2. 常用选项</h4>
        
        <table class="prop-table">
            <thead>
                <tr>
                    <th>选项</th>
                    <th>说明</th>
                    <th>示例</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>-m</code></td>
                    <td>提交信息（Message）</td>
                    <td><code>-m "install vim"</code></td>
                </tr>
                <tr>
                    <td><code>-a</code></td>
                    <td>作者信息（Author）</td>
                    <td><code>-a "Mike"</code></td>
                </tr>
                <tr>
                    <td><code>-p</code></td>
                    <td>提交时暂停容器（Pause）</td>
                    <td><code>-p</code> (默认开启)</td>
                </tr>
            </tbody>
        </table>
        
        <h4>3. 实战演示</h4>
        <ol>
            <li><strong>运行容器：</strong> <code>docker run -it --name my-ubuntu ubuntu bash</code></li>
            <li><strong>修改内容：</strong> <code>touch /new-file.txt</code></li>
            <li><strong>提交镜像：</strong> 
                <pre><code>docker commit -m "add file" my-ubuntu my-ubuntu:v1</code></pre>
            </li>
            <li><strong>验证镜像：</strong> <code>docker images | grep my-ubuntu</code></li>
        </ol>

        <div class="warning-box">
            <strong>⚠️ 为什么不推荐在生产环境使用？</strong>
            <p>虽然 <code>docker commit</code> 很方便，但它存在显著缺陷：</p>
            <ul class="checklist">
                <li><strong>黑箱操作</strong>：除了作者，没人知道镜像里到底改了什么</li>
                <li><strong>体积臃肿</strong>：容易包含不必要的临时文件</li>
                <li><strong>不可重复</strong>：很难完全复现构建过程</li>
            </ul>
            <p>因此，我们更推荐使用 <strong>Dockerfile</strong> 进行自动化构建。</p>
        </div>
    </section>


    <!-- ============================================
         第二部分：认识 Dockerfile
         ============================================ -->
    
    <section id="dockerfile-intro">
        <h2>二、认识 Dockerfile：镜像的"施工图纸"</h2>
        
        <h3>2.1 为什么需要 Dockerfile？</h3>
        
        <table class="prop-table">
            <thead>
                <tr>
                    <th>❌ 手动做镜像的问题</th>
                    <th>✅ Dockerfile 的优势</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>每次都要敲一遍命令</td>
                    <td>一次编写，自动化构建</td>
                </tr>
                <tr>
                    <td>容易遗漏步骤或打错</td>
                    <td>每一步都有文档记录</td>
                </tr>
                <tr>
                    <td>无法记录修改历史</td>
                    <td>可以版本管理（git）</td>
                </tr>
                <tr>
                    <td>难以分享给别人复现</td>
                    <td>团队协作，完全一致</td>
                </tr>
            </tbody>
        </table>
        
        <h3>2.2 分层构建原理</h3>
        <p>Dockerfile 采用分层构建，每一条指令都是在上一层基础上"叠加"一层新内容：</p>
        
<pre><code>基础镜像 (FROM)      → 第1层
    ↓
安装软件 (RUN)       → 第2层
    ↓
复制文件 (COPY)      → 第3层
    ↓
设置环境变量 (ENV)   → 第4层
    ↓
设置启动命令 (CMD)   → 第5层
    ↓
最终镜像</code></pre>

        <div class="tip-box">
            <span class="tip-title">💡 分层构建的好处</span>
            <ul class="checklist">
                <li><strong>缓存复用</strong>：已构建的层会被缓存，后续构建更快</li>
                <li><strong>增量更新</strong>：只重建变化的层</li>
                <li><strong>共享层</strong>：不同镜像可以共享相同的基础层</li>
            </ul>
        </div>
    </section>


    <!-- ============================================
         第三部分：第一个 Dockerfile
         ============================================ -->
    
    <section id="first-dockerfile">
        <h2>三、实战：动手写第一个 Dockerfile</h2>
        
        <h3>3.1 创建工作目录</h3>
<pre><code>mkdir ~/my-first-dockerfile
cd ~/my-first-dockerfile</code></pre>
        
        <h3>3.2 创建 Dockerfile</h3>
        <p>用文本编辑器创建一个名为 <code>Dockerfile</code> 的文件（注意：没有扩展名）：</p>
        
<pre><code># 使用官方 nginx 镜像作为基础
FROM nginx:alpine

# 创建一个简单的 HTML 文件
RUN echo '&lt;h1&gt;Hello from Dockerfile!&lt;/h1&gt;' > /usr/share/nginx/html/index.html

# 容器启动时运行 nginx
CMD ["nginx", "-g", "daemon off;"]</code></pre>

        <h3>3.3 逐行解析</h3>
        
        <div class="note-box">
            <strong>FROM nginx:alpine</strong>
            <p>📦 指定基础镜像。<code>nginx:alpine</code> 是一个轻量级的 nginx 镜像，基于 Alpine Linux 系统，体积只有约 40MB。</p>
        </div>
        
        <div class="note-box">
            <strong>RUN &lt;命令&gt;</strong>
            <p>🔧 在镜像构建过程中执行命令。这里用 <code>echo</code> 命令创建了一个简单的 HTML 文件。</p>
            <p><strong>执行时机：</strong>构建镜像时（docker build）</p>
        </div>
        
        <div class="note-box">
            <strong>CMD ["命令", "参数"]</strong>
            <p>🚀 指定容器启动时要运行的命令。这里让 nginx 以前台模式运行。</p>
            <p><strong>执行时机：</strong>启动容器时（docker run）</p>
        </div>
        
        <h3>3.4 构建镜像</h3>
<pre><code>docker build -t my-nginx:v1 .</code></pre>
        
        <p><strong>命令解析：</strong></p>
        <ul>
            <li><code>docker build</code> - 构建镜像的命令</li>
            <li><code>-t my-nginx:v1</code> - 给镜像起名字和标签</li>
            <li><code>.</code> - 点号表示当前目录（构建上下文）</li>
        </ul>
        
        <p>预期输出：</p>
<pre><code>[+] Building 2.1s (6/6) FINISHED
 => [internal] load build definition from Dockerfile
 => [internal] load .dockerignore
 => [internal] load metadata for docker.io/library/nginx:alpine
 => CACHED [1/2] FROM docker.io/library/nginx:alpine
 => [2/2] RUN echo '&lt;h1&gt;Hello from Dockerfile!&lt;/h1&gt;' > ...
 => exporting to image
 => => naming to docker.io/library/my-nginx:v1</code></pre>
    </section>


    <!-- ============================================
         实验 01：构建并运行第一个镜像
         ============================================ -->
    <section id="lab-1">
        <h2>实验 01：构建并运行第一个镜像</h2>
        
        <div class="lab-card">
            <div class="lab-header">
                <span>实验 01：Dockerfile 入门实践</span>
                <span class="status-badge beginner">动手实践</span>
            </div>
            <div class="lab-body">
                <p><strong>实验目标：</strong>使用刚才创建的 Dockerfile 构建镜像并运行容器</p>
                
                <ol class="lab-steps">
                    <li>确保在 <code>~/my-first-dockerfile</code> 目录下</li>
                    <li>执行构建命令：<code>docker build -t my-nginx:v1 .</code></li>
                    <li>运行容器：<code>docker run -d -p 8080:80 --name test-nginx my-nginx:v1</code></li>
                    <li>打开浏览器访问：<code>http://localhost:8080</code></li>
                    <li>验证页面显示 "Hello from Dockerfile!"</li>
                </ol>
                
                <h4>清理命令</h4>
<pre><code>docker stop test-nginx && docker rm test-nginx</code></pre>
            </div>
        </div>
        
        <div class="warning-box">
            <strong>常见问题排查</strong>
            <ul>
                <li><strong>build 提示 "Cannot connect to Docker daemon"</strong> → 确保 Docker Desktop 已启动</li>
                <li><strong>浏览器访问显示 "无法访问此网站"</strong> → 检查容器是否在运行：<code>docker ps</code></li>
                <li><strong>端口 8080 被占用</strong> → 换个端口，比如 <code>-p 8081:80</code></li>
            </ul>
        </div>
    </section>


    <!-- ============================================
         第四部分：docker build 详解
         ============================================ -->
    
    <section id="build-details">
        <h2>四、docker build 命令详解</h2>
        
        <h3>4.1 命令格式</h3>
<pre><code>docker build [选项] &lt;上下文路径&gt;</code></pre>
        
        <h3>4.2 常用选项</h3>
        
        <table class="prop-table">
            <thead>
                <tr>
                    <th>选项</th>
                    <th>说明</th>
                    <th>示例</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>-t</code></td>
                    <td>给镜像命名和打标签</td>
                    <td><code>-t my-app:v1</code></td>
                </tr>
                <tr>
                    <td><code>-f</code></td>
                    <td>指定 Dockerfile 路径</td>
                    <td><code>-f ./docker/Dockerfile</code></td>
                </tr>
                <tr>
                    <td><code>--no-cache</code></td>
                    <td>不使用缓存，强制重新构建</td>
                    <td><code>--no-cache</code></td>
                </tr>
                <tr>
                    <td><code>.</code></td>
                    <td>上下文路径（当前目录）</td>
                    <td><code>docker build -t app .</code></td>
                </tr>
            </tbody>
        </table>
        
        <h3>4.3 什么是"上下文路径"？</h3>
        <div class="tip-box">
            <span class="tip-title">理解构建上下文</span>
            <p>上下文路径就是 Docker 构建镜像时可以访问的文件范围。通常设为 <code>.</code>（当前目录），Docker 会把这个目录下的所有文件发送给 Docker 引擎用于构建。</p>
            <p><strong>⚠️ 注意：</strong>不要在包含大量无关文件的目录下执行 <code>docker build</code>，会导致构建变慢！</p>
        </div>
        
        <h3>4.4 缓存机制</h3>
        <p>Docker 会缓存每一层的构建结果：</p>
        <ul class="checklist">
            <li><strong>第一次构建</strong>：所有层都要执行，比较慢</li>
            <li><strong>第二次构建</strong>：如果 Dockerfile 没改，几乎瞬间完成</li>
            <li><strong>某层改变后</strong>：该层及后续所有层都重新构建</li>
        </ul>
    </section>


    <!-- ============================================
         第五部分：Dockerfile 常用指令
         ============================================ -->
    
    <section id="dockerfile-commands">
        <h2>五、Dockerfile 常用指令实战</h2>
        
        <h3>5.1 指令速查表</h3>
        
        <table class="prop-table">
            <thead>
                <tr>
                    <th>指令</th>
                    <th>作用</th>
                    <th>执行时机</th>
                    <th>示例</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>FROM</code></td>
                    <td>指定基础镜像</td>
                    <td>构建时</td>
                    <td><code>FROM nginx:alpine</code></td>
                </tr>
                <tr>
                    <td><code>COPY</code></td>
                    <td>复制文件</td>
                    <td>构建时</td>
                    <td><code>COPY . /app</code></td>
                </tr>
                <tr>
                    <td><code>RUN</code></td>
                    <td>执行命令</td>
                    <td>构建时</td>
                    <td><code>RUN npm install</code></td>
                </tr>
                <tr>
                    <td><code>WORKDIR</code></td>
                    <td>设置工作目录</td>
                    <td>构建时</td>
                    <td><code>WORKDIR /app</code></td>
                </tr>
                <tr>
                    <td><code>EXPOSE</code></td>
                    <td>声明端口</td>
                    <td>构建时</td>
                    <td><code>EXPOSE 80</code></td>
                </tr>
                <tr>
                    <td><code>ENV</code></td>
                    <td>设置环境变量</td>
                    <td>构建+运行时</td>
                    <td><code>ENV PORT=3000</code></td>
                </tr>
                <tr>
                    <td><code>CMD</code></td>
                    <td>启动命令</td>
                    <td>运行时</td>
                    <td><code>CMD ["node", "app.js"]</code></td>
                </tr>
            </tbody>
        </table>
        
        <h3>5.2 FROM - 指定基础镜像</h3>
<pre><code># 格式
FROM &lt;镜像名&gt;:&lt;标签&gt;

# 常用示例
FROM nginx:alpine          # 轻量级 nginx
FROM python:3.9-slim       # Python 精简版
FROM node:18-alpine        # Node.js 轻量版
FROM ubuntu:22.04          # Ubuntu 完整版</code></pre>

        <div class="tip-box">
            <span class="tip-title">镜像版本选择建议</span>
            <ul>
                <li><code>alpine</code> 版本最小（约 5MB），适合追求精简</li>
                <li><code>slim</code> 版本较小，包含基础工具</li>
                <li>不带后缀的版本最完整，但体积大</li>
            </ul>
        </div>
        
        <h3>5.3 COPY - 复制文件到镜像</h3>
<pre><code># 格式
COPY &lt;源路径&gt; &lt;目标路径&gt;

# 常用示例
COPY index.html /usr/share/nginx/html/       # 复制单个文件
COPY ./src /app/src                          # 复制整个目录
COPY package*.json /app/                     # 使用通配符</code></pre>

        <div class="warning-box">
            <strong>⚠️ 注意：</strong>源路径是相对于上下文路径的，不能访问上下文之外的文件！
        </div>
        
        <h3>5.4 RUN - 执行命令</h3>
<pre><code># 格式
RUN &lt;命令&gt;

# 常用示例
RUN apt-get update && apt-get install -y vim    # 安装软件
RUN npm install                                  # 安装依赖
RUN mkdir -p /app/logs                           # 创建目录

# ⭐ 最佳实践：合并多条命令减少镜像层数
RUN apt-get update && \
    apt-get install -y \
        vim \
        curl \
        wget && \
    rm -rf /var/lib/apt/lists/*</code></pre>
        
        <h3>5.5 WORKDIR - 设置工作目录</h3>
<pre><code># 格式
WORKDIR &lt;目录路径&gt;

# 示例
WORKDIR /app          # 后续命令都在 /app 目录下执行
COPY . .              # 等于 COPY . /app/
RUN npm install       # 在 /app 目录下执行</code></pre>

        <div class="tip-box">
            <span class="tip-title">💡 推荐使用 WORKDIR</span>
            <p>使用 WORKDIR 而不是 <code>RUN cd /app</code>，因为 WORKDIR 会持续生效。</p>
        </div>
        
        <h3>5.6 CMD vs ENTRYPOINT</h3>
        
        <table class="prop-table">
            <thead>
                <tr>
                    <th>指令</th>
                    <th>特点</th>
                    <th>示例</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>CMD</code></td>
                    <td>容器启动命令，可被 docker run 覆盖</td>
                    <td><code>CMD ["nginx", "-g", "daemon off;"]</code></td>
                </tr>
                <tr>
                    <td><code>ENTRYPOINT</code></td>
                    <td>固定的启动命令，不会被覆盖</td>
                    <td><code>ENTRYPOINT ["python", "app.py"]</code></td>
                </tr>
            </tbody>
        </table>
        
        <h3>5.7 ENV - 设置环境变量</h3>
<pre><code># 格式
ENV &lt;变量名&gt;=&lt;值&gt;

# 示例
ENV NODE_ENV=production
ENV APP_PORT=3000

# 在后续指令中使用
RUN echo "Port is $APP_PORT"</code></pre>

        <h3>5.8 EXPOSE - 声明端口</h3>
<pre><code># 格式
EXPOSE &lt;端口号&gt;

# 示例
EXPOSE 80
EXPOSE 3000
EXPOSE 8080 443       # 可以声明多个端口</code></pre>

        <div class="warning-box">
            <strong>⚠️ 注意：</strong>EXPOSE 只是声明，真正要暴露端口还需要 <code>docker run -p</code> 命令！
        </div>
    </section>


    <!-- ============================================
         实验 02：综合练习
         ============================================ -->
    <section id="lab-2">
        <h2>实验 02：Dockerfile 指令综合练习</h2>
        
        <div class="lab-card">
            <div class="lab-header">
                <span>实验 02：创建完整的 Dockerfile</span>
                <span class="status-badge beginner">动手实践</span>
            </div>
            <div class="lab-body">
                <p><strong>任务：</strong>创建一个完整的 Dockerfile，包含以下要求：</p>
                
                <ol class="lab-steps">
                    <li>使用 <code>nginx:alpine</code> 作为基础镜像</li>
                    <li>设置一个环境变量 <code>APP_VERSION=1.0</code></li>
                    <li>创建工作目录 <code>/app/web</code></li>
                    <li>复制本地的 <code>index.html</code> 到 nginx 目录</li>
                    <li>声明端口 80</li>
                    <li>设置启动命令</li>
                </ol>
                
                <h4>参考答案</h4>
<pre><code>FROM nginx:alpine

ENV APP_VERSION=1.0

WORKDIR /app/web

COPY index.html /usr/share/nginx/html/

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]</code></pre>
            </div>
        </div>
    </section>


    <!-- ============================================
         第六部分：完整项目实战
         ============================================ -->
    
    <section id="mini-project">
        <h2>六、完整项目实战：打包个人主页</h2>
        
        <p>让我们用 Dockerfile 打包一个完整的个人主页网站！</p>
        
        <h3>6.1 项目目录结构</h3>
<pre><code>my-homepage/
├── Dockerfile
├── index.html
├── css/
│   └── style.css
├── js/
│   └── main.js
└── images/
    └── (你的图片文件)</code></pre>

        <h3>6.2 创建项目目录</h3>
<pre><code>mkdir ~/my-homepage && cd ~/my-homepage
mkdir -p css js images</code></pre>

        <h3>6.3 创建 index.html</h3>
<pre class="html"><code>&lt;!DOCTYPE html&gt;
&lt;html lang="zh-CN"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;我的个人主页&lt;/title&gt;
    &lt;link rel="stylesheet" href="css/style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;header&gt;
        &lt;h1&gt;👋 欢迎来到我的主页&lt;/h1&gt;
        &lt;p&gt;这个网站是用 Docker 部署的！&lt;/p&gt;
    &lt;/header&gt;
    &lt;main&gt;
        &lt;section class="about"&gt;
            &lt;h2&gt;关于我&lt;/h2&gt;
            &lt;p&gt;我是一名正在学习 Docker 的学生。&lt;/p&gt;
        &lt;/section&gt;
        &lt;section class="skills"&gt;
            &lt;h2&gt;我的技能&lt;/h2&gt;
            &lt;ul&gt;
                &lt;li&gt;Docker 容器技术&lt;/li&gt;
                &lt;li&gt;HTML/CSS/JavaScript&lt;/li&gt;
                &lt;li&gt;Python 编程&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/section&gt;
    &lt;/main&gt;
    &lt;footer&gt;
        &lt;p&gt;© 2024 Docker 学习之旅&lt;/p&gt;
    &lt;/footer&gt;
    &lt;script src="js/main.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

        <h3>6.4 创建 css/style.css</h3>
<pre class="css"><code>* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Arial, sans-serif;
    line-height: 1.6;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    color: #333;
}

header {
    text-align: center;
    padding: 3rem 1rem;
    color: white;
}

header h1 {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
}

main {
    max-width: 800px;
    margin: 0 auto;
    padding: 2rem;
}

section {
    background: white;
    border-radius: 12px;
    padding: 2rem;
    margin-bottom: 1.5rem;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

h2 {
    color: #667eea;
    margin-bottom: 1rem;
}

footer {
    text-align: center;
    padding: 2rem;
    color: white;
}</code></pre>

        <h3>6.5 创建 js/main.js</h3>
<pre class="js"><code>// 简单的交互效果
document.addEventListener('DOMContentLoaded', function() {
    console.log('🐳 Docker 部署的网站已加载！');
    
    // 给标题添加点击效果
    const title = document.querySelector('h1');
    title.addEventListener('click', function() {
        alert('🐳 Hello from Docker!');
    });
});</code></pre>

        <h3>6.6 创建 Dockerfile</h3>
<pre><code># 使用 nginx 作为基础镜像
FROM nginx:alpine

# 设置维护者信息
LABEL maintainer="your-email@example.com"
LABEL description="我的个人主页 Docker 镜像"

# 删除 nginx 默认的欢迎页面
RUN rm -rf /usr/share/nginx/html/*

# 复制网站文件到 nginx 目录
COPY index.html /usr/share/nginx/html/
COPY css/ /usr/share/nginx/html/css/
COPY js/ /usr/share/nginx/html/js/
COPY images/ /usr/share/nginx/html/images/

# 暴露 80 端口
EXPOSE 80

# 启动 nginx
CMD ["nginx", "-g", "daemon off;"]</code></pre>

        <h3>6.7 构建和运行</h3>
<pre><code># 构建镜像
docker build -t my-homepage:v1 .

# 运行容器
docker run -d -p 8888:80 --name homepage my-homepage:v1

# 查看运行状态
docker ps</code></pre>

        <div class="tip-box">
            <span class="tip-title">🎉 完成！</span>
            <p>打开浏览器访问 <code>http://localhost:8888</code> 查看你的个人主页！</p>
        </div>
    </section>


    <!-- ============================================
         第七部分：镜像优化技巧
         ============================================ -->
    
    <section id="image-optimize">
        <h2>七、镜像优化技巧</h2>
        
        <h3>7.1 为什么要优化镜像？</h3>
        <ul class="checklist">
            <li><strong>更快的传输速度</strong> - 镜像越小，推送/拉取越快</li>
            <li><strong>更少的存储空间</strong> - 节省服务器磁盘</li>
            <li><strong>更快的构建速度</strong> - 利用缓存加速构建</li>
            <li><strong>更安全</strong> - 更少的软件意味着更少的漏洞</li>
        </ul>
        
        <h3>7.2 技巧1：选择轻量级基础镜像</h3>
        
        <table class="prop-table">
            <thead>
                <tr>
                    <th>镜像</th>
                    <th>大小</th>
                    <th>特点</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>nginx:latest</code></td>
                    <td>~140MB</td>
                    <td>完整版，包含更多工具</td>
                </tr>
                <tr>
                    <td><code>nginx:alpine</code></td>
                    <td>~40MB</td>
                    <td>⭐ 推荐，足够大多数场景</td>
                </tr>
                <tr>
                    <td><code>python:3.9</code></td>
                    <td>~900MB</td>
                    <td>完整版</td>
                </tr>
                <tr>
                    <td><code>python:3.9-slim</code></td>
                    <td>~120MB</td>
                    <td>精简版</td>
                </tr>
            </tbody>
        </table>
        
        <h3>7.3 技巧2：合并 RUN 命令减少层数</h3>
        
        <div class="warning-box">
            <strong>❌ 不推荐（产生 4 个镜像层）</strong>
<pre><code>RUN apt-get update
RUN apt-get install -y vim
RUN apt-get install -y curl
RUN rm -rf /var/lib/apt/lists/*</code></pre>
        </div>
        
        <div class="tip-box">
            <span class="tip-title">✅ 推荐（只产生 1 个镜像层）</span>
<pre><code>RUN apt-get update && \
    apt-get install -y \
        vim \
        curl && \
    rm -rf /var/lib/apt/lists/*</code></pre>
        </div>
        
        <h3>7.4 技巧3：使用 .dockerignore</h3>
        <p>在项目根目录创建 <code>.dockerignore</code> 文件，排除无用文件：</p>
        
<pre><code># 版本控制
.git
.gitignore

# 依赖目录（会在容器内重新安装）
node_modules
__pycache__

# 开发配置
.env.local
*.log

# IDE 配置
.vscode
.idea

# 文档
README.md
docs/</code></pre>

        <h3>7.5 技巧4：合理安排指令顺序</h3>
        <p>把不常变动的指令放前面，经常变动的放后面：</p>
        
<pre><code>FROM node:18-alpine

WORKDIR /app

# 1. 先复制依赖配置文件（不常变动）
COPY package*.json ./

# 2. 安装依赖（只有 package.json 变化才重新执行）
RUN npm install

# 3. 最后复制源代码（经常变动）
COPY . .

CMD ["npm", "start"]</code></pre>

        <div class="note-box">
            <strong>💡 原理：</strong>Docker 会缓存每一层。如果某层没有变化，就直接使用缓存。把经常变化的 <code>COPY . .</code> 放最后，这样改代码时前面的层都能用缓存，构建更快！
        </div>
    </section>


    <!-- ============================================
         第八部分：常见错误排查
         ============================================ -->
    
    <section id="troubleshooting">
        <h2>八、常见错误排查</h2>
        
        <h3>8.1 错误1：COPY 文件找不到</h3>
        <div class="warning-box">
            <strong>报错信息：</strong>
            <code>COPY failed: file not found in build context</code>
            <p><strong>原因：</strong>COPY 只能复制构建上下文（docker build 指定的目录）内的文件</p>
            <p><strong>解决：</strong></p>
            <ul>
                <li>检查文件是否存在</li>
                <li>检查文件路径是否正确（相对于 Dockerfile 所在目录）</li>
                <li>检查 .dockerignore 是否排除了该文件</li>
            </ul>
        </div>
        
        <h3>8.2 错误2：RUN 命令执行失败</h3>
        <div class="warning-box">
            <strong>报错信息：</strong>
            <code>returned a non-zero code: 1</code>
            <p><strong>原因：</strong>命令执行出错（如软件包不存在、权限问题等）</p>
            <p><strong>解决：</strong></p>
            <ul>
                <li>先在容器内手动测试命令</li>
                <li>检查软件包名称是否正确</li>
                <li>Alpine 镜像用 <code>apk add</code> 而不是 <code>apt-get</code></li>
            </ul>
        </div>
        
        <h3>8.3 错误3：容器启动后立即退出</h3>
        <div class="warning-box">
            <strong>原因：</strong>CMD 命令执行完毕后容器就退出了
            <p><strong>解决：</strong></p>
            <ul>
                <li>确保 CMD 是一个前台持续运行的进程</li>
                <li>nginx 需要加 <code>daemon off;</code></li>
                <li>可以用 <code>docker logs 容器名</code> 查看退出原因</li>
            </ul>
        </div>
        
        <h3>8.4 错误4：端口无法访问</h3>
        <div class="warning-box">
            <strong>原因：</strong>端口映射或防火墙问题
            <p><strong>解决：</strong></p>
            <ul>
                <li>确保用 <code>-p 宿主端口:容器端口</code> 映射了端口</li>
                <li>检查容器是否正常运行：<code>docker ps</code></li>
                <li>检查宿主机端口是否被占用</li>
            </ul>
        </div>
        
        <h3>8.5 调试技巧</h3>
<pre><code># 查看容器日志
docker logs 容器名

# 进入正在运行的容器
docker exec -it 容器名 sh

# 查看镜像构建历史
docker history 镜像名

# 以交互模式运行（调试用）
docker run -it 镜像名 sh</code></pre>
    </section>


    <!-- ============================================
         课程小结区域
         ============================================ -->
    <section id="summary">
        <h2>九、本课小结</h2>
        
        <h3>知识点回顾</h3>
        <ul class="checklist">
            <li><strong>Dockerfile</strong>：镜像的"施工图纸"，自动化构建镜像</li>
            <li><strong>FROM</strong>：指定基础镜像，必须是第一条指令</li>
            <li><strong>COPY</strong>：复制本地文件到镜像</li>
            <li><strong>RUN</strong>：在构建时执行命令</li>
            <li><strong>CMD</strong>：容器启动时执行的命令</li>
            <li><strong>WORKDIR</strong>：设置工作目录</li>
            <li><strong>EXPOSE</strong>：声明端口（只是文档作用）</li>
            <li><strong>ENV</strong>：设置环境变量</li>
        </ul>
        
        <h3>重点记忆</h3>
        <table class="prop-table">
            <thead>
                <tr>
                    <th>概念</th>
                    <th>要点</th>
                    <th>示例</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>构建镜像</td>
                    <td>使用 docker build 命令</td>
                    <td><code>docker build -t myapp:v1 .</code></td>
                </tr>
                <tr>
                    <td>运行容器</td>
                    <td>使用 docker run 命令</td>
                    <td><code>docker run -d -p 8080:80 myapp:v1</code></td>
                </tr>
                <tr>
                    <td>镜像优化</td>
                    <td>使用 alpine 版本，合并 RUN</td>
                    <td><code>FROM nginx:alpine</code></td>
                </tr>
            </tbody>
        </table>
        
        <h3>课后作业</h3>
        <ol class="lab-steps">
            <li>为个人主页添加更多页面（about.html、contact.html）</li>
            <li>尝试用 Python Flask 或 Node.js Express 写一个简单 API，并用 Dockerfile 打包</li>
            <li>比较 <code>nginx:latest</code> 和 <code>nginx:alpine</code> 镜像大小</li>
        </ol>
        
        <!-- 下一课预告 -->
        <div class="note-box">
            <strong>下一课预告：</strong>
            <p>第四讲：Docker Compose 多容器编排 - 让多个容器协同工作！我们将学习如何用一个配置文件同时管理多个容器，实现前端、后端、数据库的一键部署。</p>
        </div>
    </section>


</main>

</body>
</html>






