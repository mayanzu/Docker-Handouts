<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第5讲：Kubernetes 理论知识</title>
    <link rel="stylesheet" href="模板/统一讲义样式模板.css">
    <script src="模板/js/lecture-utils.js" defer></script>
</head>
<body>

<!-- 侧边栏导航 -->
<nav class="sidebar">
    <div class="sidebar-nav">
        <h3>课程导航</h3>
        <a class="sidebar-link" href="#intro">👋 课程概览</a>
        
        <h3>Part 1: K8S 基础概念</h3>
        <a class="sidebar-link sub-link" href="#chapter-1">一、什么是 Kubernetes</a>
        <a class="sidebar-link sub-link" href="#section-1-1">1.1 容器编排</a>
        <a class="sidebar-link sub-link" href="#section-1-2">1.2 集群与节点</a>
        <a class="sidebar-link sub-link" href="#section-1-3">1.3 核心组件</a>
        <a class="sidebar-link sub-link" href="#section-1-4">1.4 K8S 的语言：YAML</a>
        <a class="sidebar-link sub-link" href="#section-1-5">1.5 K8S 的遥控器：kubectl</a>
        
        <h3>Part 2: K8S 核心对象</h3>
        <a class="sidebar-link sub-link" href="#chapter-2">二、Pod 与 Controller</a>
        <a class="sidebar-link sub-link" href="#section-2-1">2.1 Pod 详解</a>
        <a class="sidebar-link sub-link" href="#section-2-2">2.2 Deployment</a>
        
        <h3>Part 3: 网络与存储</h3>
        <a class="sidebar-link sub-link" href="#chapter-3">三、Service 与 Volume</a>
        <a class="sidebar-link sub-link" href="#section-3-1">3.1 Service</a>
        <a class="sidebar-link sub-link" href="#section-3-2">3.2 Pod 访问指南</a>
        <a class="sidebar-link sub-link" href="#section-3-3">3.3 Volume</a>
        
        <h3>Part 4: 动手实战</h3>
        <a class="sidebar-link sub-link" href="#chapter-4">🔬 四、快速上手实验</a>

        <h3>总结与练习</h3>
        <a class="sidebar-link sub-link" href="#summary">📝 课程小结</a>
    </div>
</nav>

<!-- 主内容区 -->
<main class="content">

    <!-- 课程头部 -->
    <header id="intro">
        <h1>第5讲：K8S的理论知识</h1>
        <p class="intro">别被 Kubernetes (K8S) 这个高大上的名字吓到了！简单来说，如果 Docker 是一个个集装箱，那 K8S 就是管理这些集装箱的<strong>自动化码头操作系统</strong>。本课我们将用通俗易懂的方式，带你理解这个“容器大管家”是如何工作的。</p>
        
        <div class="pill-list">
            <span class="pill">Kubernetes</span>
            <span class="pill">容器管家</span>
            <span class="pill">Pod (豆荚)</span>
            <span class="pill">Node (工人)</span>
            <span class="pill">Service (前台)</span>
        </div>
    </header>


    <section id="chapter-1">
        <h2>一、什么是 Kubernetes (K8S)？</h2>
        <p>想象一下，你有一台电脑，上面运行着几个软件，你手动管理完全没问题。但如果你有 100 台电脑，运行着 1000 个软件，有的挂了需要重启，有的太忙了需要加机器，这时候手动管理就崩溃了。</p>
        <p><strong>Kubernetes 就是为了解决这个问题而生的“集群操作系统”。</strong> 它负责自动化地部署应用、根据流量自动扩缩容、并在机器故障时自动修复。</p>
        <div class="note-box">
            <strong>为什么叫 K8S？</strong>
            <p>Kubernetes 是希腊语“舵手”的意思。因为它名字太长了（中间有8个字母），所以大家偷懒叫它 <strong>K8S</strong>。</p>
        </div>
    </section>

    <section id="section-1-1">
        <h3>1.1 为什么要用它？（容器编排）</h3>
        <p>回到我们的<strong>“自动化码头”</strong>类比：</p>
        <ul class="checklist">
            <li><strong>自动搬运（调度）</strong>：你只需要把集装箱（容器）扔给 K8S，它会自动寻找空闲的船（服务器）把它放上去，不用你操心。</li>
            <li><strong>自动修复（自愈）</strong>：如果某个集装箱坏了，或者某艘船沉了，K8S 会自动在其他地方重新启动一个新的，保证业务不中断。</li>
            <li><strong>自动调整（弹性）</strong>：双十一来了，货物太多？K8S 会自动增加集装箱数量；大促结束，它又会自动减少，帮你省钱。</li>
        </ul>
    </section>

    <section id="section-1-2">
        <h3>1.2 集群与节点 (Cluster & Node)</h3>
        <p><strong>集群 (Cluster)</strong> 是 Kubernetes 的基本物理形态。简单来说，就是<strong>把一堆电脑连起来，当成一台超级电脑来用</strong>。</p>
        <p>在 K8S 的世界里，我们不再关心某一个具体的服务器，我们只关心整个<strong>集群</strong>还有多少 CPU、多少内存。你把任务交给集群，集群自己决定派谁去干活。</p>

        <h4>Node (节点) 详解</h4>
        
        <div class="concept-box">
            <span class="tip-title">核心概念：Node (节点)</span>
            <p><strong>Node</strong> 是 K8S 集群中的<strong>工作机器</strong>（Worker Machine），它可以是物理机，也可以是虚拟机。它是 Pod 运行的地方。</p>
            <ul class="checklist">
                <li><strong>资源 (Capacity)</strong>：Node 提供 CPU、内存和磁盘空间。K8S 调度器会根据 Node 的剩余资源，决定把 Pod 放在哪里。</li>
                <li><strong>状态 (Status)</strong>：
                    <ul>
                        <li><code>Ready</code>：健康，可以干活。</li>
                        <li><code>NotReady</code>：故障（比如断网、死机），K8S 会自动把上面的任务转移到其他 Node。</li>
                    </ul>
                </li>
                <li><strong>信息 (Info)</strong>：包含内核版本、Docker 版本、IP 地址等。</li>
            </ul>
        </div>

        <h4>对比：Master vs Node</h4>
        <table class="prop-table">
            <thead>
                <tr>
                    <th>角色</th>
                    <th>Master (控制平面)</th>
                    <th>Node (工作节点)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>职责</strong></td>
                    <td><strong>大脑</strong> (决策、调度、管理)</td>
                    <td><strong>手脚</strong> (干活、运行容器)</td>
                </tr>
                <tr>
                    <td><strong>数量</strong></td>
                    <td>通常 3 台 (为了高可用)</td>
                    <td>几台到几千台不等</td>
                </tr>
                <tr>
                    <td><strong>运行组件</strong></td>
                    <td>API Server, Scheduler, etcd</td>
                    <td>Kubelet, Kube-proxy, Docker</td>
                </tr>
                <tr>
                    <td><strong>如果挂了</strong></td>
                    <td>集群无法管理 (无法发新指令)</td>
                    <td>集群计算能力下降 (任务转移)</td>
                </tr>
            </tbody>
        </table>
    </section>

    <section id="section-1-3">
        <h3>1.3 核心组件：K8S 的“公司架构”</h3>
        <p>K8S 集群就像一家<strong>高效运转的公司</strong>，主要分为“管理层”（Control Plane）和“干活的员工”（Node）。</p>
        
        <!-- 终端模拟器：查看集群节点 -->
        <div class="terminal-window">
            <div class="terminal-header">
                <span class="terminal-btn red"></span>
                <span class="terminal-btn yellow"></span>
                <span class="terminal-btn green"></span>
                <span class="terminal-title">bash</span>
            </div>
            <div class="terminal-body">
                <div class="command-line">
                    <span class="prompt">$</span> <span class="command">kubectl get nodes</span>
                </div>
                <div class="output">
NAME           STATUS   ROLES           AGE   VERSION
k8s-master     Ready    control-plane   10d   v1.28.0
k8s-node-1     Ready    &lt;none&gt;          10d   v1.28.0
k8s-node-2     Ready    &lt;none&gt;          10d   v1.28.0
                </div>
                <div class="command-line">
                    <span class="prompt">$</span> <span class="command">_</span>
                </div>
            </div>
        </div>

<pre class="ascii-diagram">
+-----------------------------------+       +-----------------------------------------------------------+
|  管理层 (Control Plane / Master)  |       |                   员工层 (Worker Nodes)                   |
|                                   |       |                                                           |
| +------------+   +-------------+  | 指令  | +-----------------------+     +-----------------------+   |
| | API Server |---|  Scheduler  |--+------>| |    Node 1 (192.168.1) |     |    Node 2 (192.168.2) |   |
| |  (大秘书)  |   |   (HR调度)  |  |       | | +-------+   +-------+ |     | +-------+   +-------+ |   |
| +------------+   +-------------+  |       | | |Kubelet|   |K-Proxy| |     | |Kubelet|   |K-Proxy| |   |
|       |                 |         |       | | +-------+   +-------+ |     | +-------+   +-------+ |   |
| +------------+   +-------------+  |       | |     |           |     |     |     |           |     |   |
| |    etcd    |   |  Controller |  |       | | +-------+   +-------+ |     | +-------+             |   |
| |  (档案室)  |   |   (监工)    |  |       | | |  Pod  |   |  Pod  | |     | |  Pod  |             |   |
| +------------+   +-------------+  |       | | +-------+   +-------+ |     | +-------+             |   |
+-----------------------------------+       +-----------------------------------------------------------+
</pre>

        <h4>管理层 (Control Plane) - 负责决策</h4>
        <ul class="checklist">
            <li><strong>API Server (大秘书)</strong>：公司的唯一对外窗口。所有指令（比如“我要部署一个应用”）都必须先告诉它，由它传达给其他人。</li>
            <li><strong>Scheduler (HR/调度员)</strong>：负责招人安排工位。它会看哪个节点（Node）有空闲资源（CPU/内存），就把任务分配过去。</li>
            <li><strong>Controller Manager (监工)</strong>：负责盯着干活。比如你要求有 3 个人干活，如果发现少了一个，它会立马再招一个。</li>
            <li><strong>etcd (档案室)</strong>：公司的数据库。记录了集群里所有的信息（谁在干活、干什么活）。</li>
        </ul>

        <h4>员工层 (Node) - 负责干活</h4>
        <ul class="checklist">
            <li><strong>Kubelet (工长)</strong>：每个节点上都有一个工长。它听大秘书（API Server）的指挥，管理自己节点上的容器。</li>
            <li><strong>Kube-proxy (门卫/接线员)</strong>：负责网络。确保外面的请求能找到正确的容器。</li>
        </ul>

        <div class="tip-box">
            <span class="tip-title">全景故事：一个 Pod 的诞生记</span>
            <p>为了让你明白这些组件是怎么配合的，我们来看一个<strong>“老板下达任务”</strong>的流程：</p>
            <ol>
                <li><strong>你 (老板)</strong> 对 <strong>API Server (大秘书)</strong> 说：“给我启动一个 Nginx！”（执行 <code>kubectl apply</code>）。</li>
                <li><strong>API Server</strong> 把这个需求记在 <strong>etcd (档案室)</strong> 里，然后贴出招聘启事。</li>
                <li><strong>Scheduler (HR)</strong> 看到启事，发现 Node 1 机器比较空闲，就决定：“把它安排在 Node 1 吧！”。</li>
                <li><strong>Node 1 上的 Kubelet (工长)</strong> 收到通知，立马干活，启动了 Nginx 容器。</li>
                <li><strong>Controller Manager (监工)</strong> 持续盯着，如果 Nginx 挂了，它会立马通知大秘书再搞一个新的。</li>
            </ol>
            <p><strong>你看，整个过程你只需要跟“大秘书”交互，其他的脏活累活 K8S 内部自己就协调好了。</strong></p>
        </div>
    </section>

    <section id="section-1-4">
        <h3>1.4 K8S 的语言：YAML</h3>
        <p>在 K8S 里，我们怎么告诉集群“我要启动一个 Nginx”呢？我们不是通过鼠标点击，而是通过写一个<strong>配置文件</strong>。这个文件通常使用 <strong>YAML</strong> 格式。</p>
        
        <h4>什么是 YAML？</h4>
        <p>YAML 是一种非常容易阅读的数据格式。它不像 XML 那样有一堆尖括号 <code>&lt;&gt;</code>，也不像 JSON 那样有一堆大括号 <code>{}</code>。它主要靠<strong>缩进</strong>来表示层级关系。</p>

        <div class="tip-box">
            <span class="tip-title">YAML 语法三定律</span>
            <ul class="checklist">
                <li><strong>缩进代表层级</strong>：就像写 Python 代码一样，左边对齐的元素属于同一级。<strong>严禁使用 Tab 键，必须用空格！</strong>（通常是 2 个空格）。</li>
                <li><strong>冒号后要空格</strong>：<code>key: value</code>，冒号后面必须跟一个空格。</li>
                <li><strong>短横线代表列表</strong>：<code>- item</code> 表示这是一个列表项。</li>
            </ul>
        </div>

        <h4>对比一下：JSON vs YAML</h4>
        <div class="two-col">
            <div>
                <p><strong>JSON (给机器看)</strong></p>
<pre><code class="language-json">{
  "name": "zhangsan",
  "age": 18,
  "skills": ["docker", "k8s"]
}</code></pre>
            </div>
            <div>
                <p><strong>YAML (给人看)</strong></p>
<pre class="yaml"><code>name: zhangsan
age: 18
skills:
  - docker
  - k8s</code></pre>
            </div>
        </div>
        <p>在 K8S 中，我们就是用这种格式来描述“我要什么样的 Pod”、“我要什么样的 Service”。这被称为<strong>“声明式 API”</strong>。</p>
    </section>

    <section id="section-1-5">
        <h3>1.5 K8S 的遥控器：kubectl</h3>
        <p>有了集群（游戏主机），有了 YAML（游戏卡带），我们还需要一个<strong>手柄</strong>来操作它。这个手柄就是 <strong>kubectl</strong> 命令行工具。</p>
        
        <h4>命令公式</h4>
        <p>kubectl 的命令非常符合直觉，基本遵循这个公式：</p>
        <div class="note-box">
            <code>kubectl [动作] [资源类型] [资源名称]</code>
            <p>例如：<code>kubectl get pod my-pod</code> （获取 名为 my-pod 的 pod 的信息）</p>
        </div>

        <h4>六大高频命令速查</h4>
        <table class="prop-table">
            <thead>
                <tr>
                    <th>动作</th>
                    <th>命令示例</th>
                    <th>作用 (人话版)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>查列表</strong></td>
                    <td><code>kubectl get pods</code></td>
                    <td>看看有哪些 Pod，状态是死是活。</td>
                </tr>
                <tr>
                    <td><strong>查详情</strong></td>
                    <td><code>kubectl describe pod xxx</code></td>
                    <td>Pod 启动失败了？用这个看报错原因（Event）。</td>
                </tr>
                <tr>
                    <td><strong>看日志</strong></td>
                    <td><code>kubectl logs xxx</code></td>
                    <td>程序报错了？用这个看控制台输出。</td>
                </tr>
                <tr>
                    <td><strong>进容器</strong></td>
                    <td><code>kubectl exec -it xxx -- bash</code></td>
                    <td>像 SSH 一样进入容器内部去调试。</td>
                </tr>
                <tr>
                    <td><strong>创建/更新</strong></td>
                    <td><code>kubectl apply -f xxx.yaml</code></td>
                    <td>把 YAML 文件提交给 K8S 执行。</td>
                </tr>
                <tr>
                    <td><strong>删除</strong></td>
                    <td><code>kubectl delete pod xxx</code></td>
                    <td>删掉某个资源。</td>
                </tr>
            </tbody>
        </table>
    </section>

    <section id="chapter-2">
        <h2>二、Pod 与 Controller</h2>
        <p>Kubernetes 中有一系列核心对象，用于表示系统的状态。</p>
    </section>

    <section id="section-2-1">
        <h3>2.1 Pod 详解 (豆荚)</h3>
        
        <div class="concept-box">
            <span class="tip-title">核心概念：Pod</span>
            <p><strong>Pod 是 Kubernetes 中最小的调度单位。</strong></p>
            <p>它不是一个容器，而是一个<strong>"容器组"</strong>。它就像一个豌豆荚，里面可以包含一个或多个紧密协作的容器（豌豆）。这些容器共享网络（IP）和存储（Volume）。</p>
        </div>

        <p>为什么不直接管理容器？因为有时候几个容器需要紧密合作，比如一个负责 Web 服务，另一个负责收集它的日志。它们就像<strong>豌豆荚（Pod）里的几粒豌豆（Container）</strong>，必须住在一起，共享同一个 IP，共享同一块存储。</p>
        
        <!-- 终端模拟器：查看 Pod -->
        <div class="terminal-window">
            <div class="terminal-header">
                <span class="terminal-btn red"></span>
                <span class="terminal-btn yellow"></span>
                <span class="terminal-btn green"></span>
                <span class="terminal-title">bash</span>
            </div>
            <div class="terminal-body">
                <div class="command-line">
                    <span class="prompt">$</span> <span class="command">kubectl get pods -o wide</span>
                </div>
                <div class="output">
NAME           READY   STATUS    RESTARTS   AGE   IP           NODE
nginx-pod      1/1     Running   0          5m    10.244.1.5   k8s-node-1
mysql-pod      1/1     Running   0          2h    10.244.2.3   k8s-node-2
                </div>
                <div class="command-line">
                    <span class="prompt">$</span> <span class="command">_</span>
                </div>
            </div>
        </div>

<pre class="ascii-diagram">
+--------------------------------------------------------------------------------------------------+
|                                       Pod (豌豆荚)                                               |
|                                    共享 IP: 10.244.1.5                                           |
|                                                                                                  |
|      +-------------------------+           +-------------------------+       +----------------+  |
|      |      主容器 (豆子)      |           |     助手容器 (豆子)     |       |    共享存储    |  |
|      |        (Nginx)          |           |       (Log Agent)       |       |    (Volume)    |  |
|      +------------+------------+           +------------+------------+       +--------+-------+  |
|                   |                                     |                             ^          |
|                   |             (localhost)             |                             |          |
|                   +-------------------------------------+                             |          |
|                   |                                                                   |          |
|                   +-------------------------(读写)------------------------------------+          |
|                                                                                                  |
+--------------------------------------------------------------------------------------------------+
</pre>

        <div class="tip-box">
            <span class="tip-title">Pod 的三大特点</span>
            <ul class="checklist">
                <li><strong>共享网络</strong>：Pod 里的容器就像住在同一个房间，可以用 <code>localhost</code> 互相说话。</li>
                <li><strong>共享存储</strong>：Pod 里的容器可以读写同一个文件夹（Volume）。</li>
                <li><strong>生命短暂</strong>：Pod 很容易死（被删除或机器故障）。死了就死了，K8S 不会复活它，而是会创建一个<strong>新的</strong> Pod 来代替它。</li>
            </ul>
        </div>

        <div class="warning-box">
            <span class="tip-title">深度解密：Pod 是如何“共享”的？(Pause 容器)</span>
            <p>你可能会问：Docker 里的容器明明是隔离的，为什么 Pod 里的容器能共享 IP？</p>
            <p>其实，每个 Pod 里都有一个<strong>隐藏的、你看不到的容器</strong>，叫做 <strong>Pause 容器</strong>（也叫 Infra 容器）。</p>
            <ul class="checklist">
                <li><strong>第一步</strong>：Pod 启动时，先启动这个 Pause 容器。它非常小（几百 KB），什么都不干，就负责<strong>“占坑”</strong>（创建 Network Namespace）。</li>
                <li><strong>第二步</strong>：其他的业务容器（比如 Nginx、MySQL）启动时，不创建自己的网络，而是<strong>直接加入</strong> Pause 容器的网络空间。</li>
                <li><strong>结果</strong>：所有容器就像“寄生”在 Pause 容器身上一样。它们看到的是<strong>同一张网卡、同一个 IP、同一套端口范围</strong>。</li>
            </ul>
            <p><strong>这也意味着：</strong>Pod 里的容器不能占用相同的端口！如果 Nginx 用了 80，LogAgent 就绝对不能再用 80，否则会冲突。</p>
        </div>

        <h4>对比：Pod vs 容器 (Docker Container)</h4>
        <table class="prop-table">
            <thead>
                <tr>
                    <th>特性</th>
                    <th>容器 (Container)</th>
                    <th>Pod</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>类比</strong></td>
                    <td>一个程序 (App)</td>
                    <td>一个进程组 / 一台虚拟机</td>
                </tr>
                <tr>
                    <td><strong>包含关系</strong></td>
                    <td>最小单位</td>
                    <td>包含一个或多个容器</td>
                </tr>
                <tr>
                    <td><strong>IP 地址</strong></td>
                    <td>每个容器有独立 IP</td>
                    <td>Pod 内所有容器共享一个 IP</td>
                </tr>
                <tr>
                    <td><strong>端口</strong></td>
                    <td>独占端口</td>
                    <td>共享端口 (不能冲突)</td>
                </tr>
            </tbody>
        </table>

        <h4>Pod 的“身份证” (YAML)</h4>
        <p>在 K8S 里，我们用 YAML 文件来描述一个 Pod 长什么样。这就像给 K8S 递交一份“申请表”。</p>
        <ul class="checklist">
            <li><strong>apiVersion</strong>: 告诉 K8S 我们要用哪个版本的 API（Pod 通常是 v1）。</li>
            <li><strong>kind</strong>: 告诉 K8S 我们要创建什么东西（这里是 Pod）。</li>
            <li><strong>metadata</strong>: 给这个 Pod 起个名字，打个标签。</li>
            <li><strong>spec</strong>: 详细说明书，比如用什么镜像、开放什么端口。</li>
        </ul>
<pre class="yaml"><code>apiVersion: v1
kind: Pod              # 类型：Pod
metadata:
  name: my-nginx-pod   # 名字：my-nginx-pod
spec:
  containers:          # 包含的容器列表
  - name: nginx        # 容器名字
    image: nginx:latest # 用什么镜像
</code></pre>
    </section>
    </section>

    <section id="section-2-2">
        <h3>2.2 Deployment (包工头)</h3>
        
        <div class="concept-box">
            <span class="tip-title">核心概念：Deployment</span>
            <p><strong>Deployment 是 Pod 的"包工头"（控制器）。</strong></p>
            <p>它负责管理 Pod 的副本数量和版本更新。你只需要告诉它"我要 3 个 Nginx"，它就会自动创建并监控这些 Pod，确保数量永远达标。</p>
        </div>

        <p>虽然我们可以直接创建 Pod，但如果 Pod 死了，没人帮我们重启。所以我们需要一个<strong>“包工头”——Deployment</strong>。</p>
        <p>Deployment 的工作原理是<strong>“声明式”</strong>的：你只需要告诉它“我要 3 个 Nginx”，它就会想尽办法保证任何时候都有 3 个 Nginx 在运行。如果少了一个，它就自动补一个。</p>

        <!-- 终端模拟器：查看 Deployment -->
        <div class="terminal-window">
            <div class="terminal-header">
                <span class="terminal-btn red"></span>
                <span class="terminal-btn yellow"></span>
                <span class="terminal-btn green"></span>
                <span class="terminal-title">bash</span>
            </div>
            <div class="terminal-body">
                <div class="command-line">
                    <span class="prompt">$</span> <span class="command">kubectl get deploy</span>
                </div>
                <div class="output">
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     3            3           10m
                </div>
                <div class="command-line">
                    <span class="prompt">$</span> <span class="command">kubectl get pods</span>
                </div>
                <div class="output">
NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-57d84f57dc-abcde   1/1     Running   0          10m
nginx-deployment-57d84f57dc-fghij   1/1     Running   0          10m
nginx-deployment-57d84f57dc-klmno   1/1     Running   0          10m
                </div>
                <div class="command-line">
                    <span class="prompt">$</span> <span class="command">_</span>
                </div>
            </div>
        </div>

        <h4>Deployment 的核心功能</h4>
        <ul class="checklist">
            <li><strong>自动补货 (Replicas)</strong>：时刻监控，保证副本数量永远达标。</li>
            <li><strong>滚动更新 (Rolling Update)</strong>：版本升级时，它会先启动一个新版本，确认没问题了再关掉一个旧版本，平滑过渡，用户无感知。</li>
        </ul>

        <h4>对比：Deployment vs Pod</h4>
        <table class="prop-table">
            <thead>
                <tr>
                    <th>特性</th>
                    <th>Pod (临时工)</th>
                    <th>Deployment (包工头)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>创建方式</strong></td>
                    <td>直接创建 Pod</td>
                    <td>创建 Deployment，由它自动创建 Pod</td>
                </tr>
                <tr>
                    <td><strong>如果挂了</strong></td>
                    <td>彻底消失，不会重启</td>
                    <td><strong>自动创建一个新的</strong>补上</td>
                </tr>
                <tr>
                    <td><strong>扩缩容</strong></td>
                    <td>手动一个个创建/删除</td>
                    <td>改一个数字 (replicas) 即可</td>
                </tr>
                <tr>
                    <td><strong>版本升级</strong></td>
                    <td>手动删旧的，建新的</td>
                    <td>全自动滚动更新，不中断服务</td>
                </tr>
            </tbody>
        </table>

        <h4>Deployment YAML 示例</h4>
        <p>Deployment 的 YAML 比 Pod 稍微复杂一点，因为它多了一层“管理逻辑”。</p>
        <ul class="checklist">
            <li><strong>replicas</strong>: 副本数。你想要几个 Pod，就填几。</li>
            <li><strong>selector</strong>: 选择器。Deployment 怎么知道哪些 Pod 归它管？就靠这个选择器去匹配 Pod 的标签。</li>
            <li><strong>template</strong>: 模板。如果需要创建新的 Pod，就按照这个模板来造。</li>
        </ul>
<pre class="yaml"><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3               # 【关键】我要 3 个副本！
  selector:
    matchLabels:
      app: nginx            # 管理贴有 "app: nginx" 标签的 Pod
  template:                 # 下面是 Pod 的模板（图纸）
    metadata:               # 定义将来生出来的 Pod 长什么样
      labels:
        app: nginx          # 【重要】给新生的 Pod 贴上标签。
                            # 必须和上面的 selector 一致！否则 Deployment 生了孩子不认识。
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
</code></pre>
    </section>

    <section id="chapter-3">
        <h2>三、Service 与 Volume</h2>
        <p>为了解决 Pod 的动态变化带来的访问和存储问题，K8S 引入了 Service 和 Volume。</p>
    </section>

    <section id="section-3-1">
        <h3>3.1 Service (固定电话)</h3>
        
        <div class="concept-box">
            <span class="tip-title">核心概念：Service</span>
            <p><strong>Service 是 K8S 中的"服务发现"和"负载均衡"机制。</strong></p>
            <p>它为一组动态变化的 Pod 提供一个<strong>固定的 IP 地址 (ClusterIP)</strong> 和 DNS 域名。无论后端的 Pod 如何销毁重建，Service 的 IP 永远不变。</p>
        </div>

        <p>前面说过，Pod 很容易死，每次重启 IP 都会变。如果你的前端应用写死了后端 Pod 的 IP，那后端一重启，前端就找不到人了。</p>
        <p><strong>Service 就是为了解决这个问题。</strong> 它就像一个<strong>“固定电话号码”</strong>（或者公司的前台）。不管后端的 Pod 怎么变、换了多少次，Service 的 IP 永远不变。请求打给 Service，它会自动把流量转发给后面活着的 Pod。</p>
        
        <!-- 终端模拟器：查看 Service -->
        <div class="terminal-window">
            <div class="terminal-header">
                <span class="terminal-btn red"></span>
                <span class="terminal-btn yellow"></span>
                <span class="terminal-btn green"></span>
                <span class="terminal-title">bash</span>
            </div>
            <div class="terminal-body">
                <div class="command-line">
                    <span class="prompt">$</span> <span class="command">kubectl get svc</span>
                </div>
                <div class="output">
NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP   10d
my-service   ClusterIP   10.96.100.110   &lt;none&gt;        80/TCP    5m
                </div>
                <div class="command-line">
                    <span class="prompt">$</span> <span class="command">_</span>
                </div>
            </div>
        </div>

<pre class="ascii-diagram">
                               +-------------------------------------+
                               |               Service               |
                               |       (固定 IP: 10.96.100.110)      |
                               +------------------+------------------+
                                                  |
                  +-------------------------------+-------------------------------+
                  |                    (自动转发给活着的 Pod)                     |
                  v                               v                               v
+-----------------------------------+   +-----------------------------------+   +-------------------+
|               Pod A               |   |               Pod B               |   |       Pod C       |
|           IP: 10.1.1.2            |   |           IP: 10.1.1.3            |   |   IP: 10.1.1.4    |
+-----------------------------------+   +-----------------------------------+   +-------------------+
</pre>

        <h4>Service 怎么知道转发给谁？(标签)</h4>
        <p>Service 不看名字，只看<strong>标签 (Label)</strong>。只要 Pod 身上贴了 <code>app: nginx</code> 这个标签，Service 就会把它纳入管理范围。</p>

        <div class="warning-box">
            <span class="tip-title">深度解密：Service IP 是真的 IP 吗？(VIP 技术)</span>
            <p>你可能会发现，Service 的 IP (ClusterIP) 根本 ping 不通，或者在机器的网卡上找不到。这是为什么？</p>
            <p><strong>因为 Service IP 是一个“虚拟 IP” (VIP)。</strong></p>
            <ul class="checklist">
                <li><strong>不是真实的网卡</strong>：它只是一条<strong>iptables 或 IPVS 规则</strong>，并不对应任何物理设备。</li>
                <li><strong>kube-proxy 的魔法</strong>：每台机器上都有一个 <code>kube-proxy</code> 组件。当你访问 Service IP 时，<code>kube-proxy</code> 会拦截这个请求，把它<strong>偷偷修改</strong>成某个具体 Pod 的 IP。</li>
                <li><strong>负载均衡</strong>：如果有 3 个 Pod，<code>kube-proxy</code> 会随机（或轮询）选择一个 Pod IP 进行转发，从而实现负载均衡。</li>
            </ul>
            <p><strong>DNS 域名解析</strong>：除了 IP，K8S 还为每个 Service 分配了一个域名（比如 <code>my-service</code>）。在集群内部，你可以直接用名字访问，不用记 IP。这就像你访问 <code>baidu.com</code> 而不是记它的 IP 一样。</p>
        </div>

        <h4>对比：Service vs 直接访问 Pod IP</h4>
        <table class="prop-table">
            <thead>
                <tr>
                    <th>特性</th>
                    <th>直接访问 Pod IP</th>
                    <th>使用 Service (推荐)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>IP 稳定性</strong></td>
                    <td><strong>极不稳定</strong> (Pod 重启 IP 就会变)</td>
                    <td><strong>绝对稳定</strong> (Service IP 终身不变)</td>
                </tr>
                <tr>
                    <td><strong>负载均衡</strong></td>
                    <td>无 (只能手动指定访问某一个)</td>
                    <td><strong>自动分发</strong>流量给所有健康的 Pod</td>
                </tr>
                <tr>
                    <td><strong>客户端感知</strong></td>
                    <td>必须时刻追踪所有 Pod 的新 IP</td>
                    <td>只需要记住 Service 的一个 IP 即可</td>
                </tr>
                <tr>
                    <td><strong>维护难度</strong></td>
                    <td>极高 (噩梦模式)</td>
                    <td>零 (自动发现，省心模式)</td>
                </tr>
            </tbody>
        </table>

        <h4>Service YAML 示例</h4>
        <p>Service 的核心任务是“找到人”和“转发流量”。</p>
        <ul class="checklist">
            <li><strong>selector</strong>: 同样是选择器。Service 通过这个标签找到后端的一组 Pod。</li>
            <li><strong>ports</strong>: 端口配置。
                <ul>
                    <li><code>port</code>: Service 自己暴露的端口（比如 80）。</li>
                    <li><code>targetPort</code>: 转发到 Pod 里的哪个端口（比如 Nginx 默认的 80）。</li>
                </ul>
            </li>
            <li><strong>type</strong>: Service 的类型（见下文）。</li>
        </ul>
<pre class="yaml"><code>apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: nginx       # 【关键】只要贴了 app: nginx 标签的 Pod，我都管！
  ports:
    - port: 80       # Service 自己的端口
      targetPort: 80 # 转发给 Pod 的端口
  type: ClusterIP    # 默认类型，只能内网访问
</code></pre>



        <h4>终极对比：Deployment vs Service</h4>
        <p>很多初学者容易搞混这两个概念。简单来说，一个是<strong>管人的（后台）</strong>，一个是<strong>管事的（前台）</strong>。</p>
        <table class="prop-table">
            <thead>
                <tr>
                    <th>维度</th>
                    <th>Deployment (管生杀)</th>
                    <th>Service (管访问)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>核心职责</strong></td>
                    <td><strong>管理 Pod 的生命周期</strong><br>(创建、重启、升级、扩容)</td>
                    <td><strong>管理 Pod 的网络访问</strong><br>(提供固定 IP、负载均衡)</td>
                </tr>
                <tr>
                    <td><strong>生活类比</strong></td>
                    <td><strong>后勤部/包工头</strong><br>(负责招人、裁人、换人)</td>
                    <td><strong>前台/总机</strong><br>(负责接电话，转给有空的员工)</td>
                </tr>
                <tr>
                    <td><strong>关注点</strong></td>
                    <td>保证 Pod <strong>活着</strong>，且数量够</td>
                    <td>保证 Pod <strong>能被找到</strong>，且流量均匀</td>
                </tr>
                <tr>
                    <td><strong>如果没了它</strong></td>
                    <td>Pod 死了没人管，服务会挂</td>
                    <td>Pod 活着但没人知道 IP，服务无法访问</td>
                </tr>
            </tbody>
        </table>
    </section>

    <section id="section-3-2">
        <h3>3.2 Pod 访问策略实战指南</h3>
        <p>在 K8S 中，Pod 的 IP 是动态的（重启就变），直接访问很不稳定。为了实现可靠访问，K8S 提供了多种机制，主要分为<strong>集群内</strong>、<strong>集群外</strong>以及<strong>开发调试</strong>三大类。</p>

        <h4>1. 集群内部访问 (Cluster Internal)</h4>
        <p>这是最常见的场景，比如前端 Pod 访问后端 Pod。</p>
        <ul class="checklist">
            <li><strong>Service (ClusterIP) - 推荐方式</strong>：
                <ul>
                    <li><strong>原理</strong>：Service 有一个固定的虚拟 IP (ClusterIP) 和 DNS 域名。无论后端 Pod 怎么变，这个 IP 和域名永远不变。</li>
                    <li><strong>访问方式</strong>：<code>http://&lt;service-name&gt;</code> (DNS) 或直接用 ClusterIP。</li>
                </ul>
            </li>
            <li><strong>Pod IP - 不推荐</strong>：
                <ul>
                    <li><strong>局限</strong>：仅适用于临时调试。一旦 Pod 重启，IP 就会变。</li>
                </ul>
            </li>
        </ul>

        <h4>2. 集群外部访问 (External Access)</h4>
        <p>如果你需要从浏览器或外部服务器访问 Pod，需要将服务“暴露”出来。</p>
        <ul class="checklist">
            <li><strong>NodePort</strong>：
                <ul>
                    <li><strong>原理</strong>：在集群的每个节点上开启一个端口（比如 30000-32767）。</li>
                    <li><strong>访问方式</strong>：<code>http://&lt;任意节点IP&gt;:&lt;NodePort&gt;</code>。适合测试。</li>
                </ul>
            </li>
            <li><strong>LoadBalancer</strong>：
                <ul>
                    <li><strong>原理</strong>：调用云厂商（阿里云/AWS）的 API 申请一个公网负载均衡器。</li>
                    <li><strong>访问方式</strong>：直接访问云厂商提供的公网 IP。适合生产环境。</li>
                </ul>
            </li>
            <li><strong>Ingress (网关) - 生产首选</strong>：
                <ul>
                    <li><strong>原理</strong>：相当于集群的“反向代理”（类似 Nginx）。只需要一个外部 IP，就能根据<strong>域名</strong>转发给不同的 Service。</li>
                    <li><strong>访问方式</strong>：<code>http://api.example.com</code> -> Ingress -> Service -> Pod。</li>
                </ul>
            </li>
        </ul>

        <h4>3. 开发与调试访问 (Dev & Debug)</h4>
        <p>当你只想临时连接到 Pod 看看情况时，可以使用以下工具：</p>
        <table class="prop-table">
            <thead>
                <tr>
                    <th>工具</th>
                    <th>命令示例</th>
                    <th>用途</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Port Forward</strong></td>
                    <td><code>kubectl port-forward pod/xxx 8080:80</code></td>
                    <td>把本地电脑的 8080 映射到 Pod 的 80。适合本地开发测试。</td>
                </tr>
                <tr>
                    <td><strong>Exec</strong></td>
                    <td><code>kubectl exec -it xxx -- bash</code></td>
                    <td>直接进入容器内部，像 SSH 一样。</td>
                </tr>
                <tr>
                    <td><strong>Proxy</strong></td>
                    <td><code>kubectl proxy</code></td>
                    <td>在本地启动代理，通过 API Server 访问 Pod。</td>
                </tr>
            </tbody>
        </table>

        <div class="tip-box">
            <span class="tip-title">总结：该选哪种？</span>
            <ul class="checklist">
                <li><strong>Pod 调 Pod</strong>：用 <strong>Service (ClusterIP)</strong> + DNS 域名。</li>
                <li><strong>浏览器访问应用</strong>：用 <strong>Ingress</strong>（生产）或 <strong>NodePort</strong>（测试）。</li>
                <li><strong>本地快速排错</strong>：用 <strong>kubectl port-forward</strong>。</li>
            </ul>
        </div>
    </section>
    
    <section id="section-3-3">
        <h3>3.3 Volume (外接硬盘)</h3>
        <p>容器里的文件是临时的，容器一删，文件就没了。如果你运行的是数据库，这简直是灾难。</p>
        <p><strong>Volume 就像一个外接硬盘或 U 盘。</strong> 即使容器坏了、换了，只要挂载了这个 Volume，数据就还在。</p>
        
        <h4>常见的 Volume 类型</h4>
        <ul class="checklist">
            <li><strong>emptyDir (临时目录)</strong>：Pod 死了数据就没了。适合放缓存。</li>
            <li><strong>hostPath (本机目录)</strong>：直接用服务器硬盘上的文件夹。</li>
            <li><strong>PVC (云盘)</strong>：申请一块持久化的存储空间，不管 Pod 搬到哪台机器，数据都跟着走。</li>
        </ul>

        <h4>对比：容器内存储 vs Volume</h4>
        <table class="prop-table">
            <thead>
                <tr>
                    <th>特性</th>
                    <th>容器内存储 (默认)</th>
                    <th>Volume (挂载存储)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>生命周期</strong></td>
                    <td><strong>与容器共存亡</strong> (容器删了，数据就丢了)</td>
                    <td><strong>独立存在</strong> (容器删了，数据还在)</td>
                </tr>
                <tr>
                    <td><strong>数据共享</strong></td>
                    <td>只能被当前容器访问</td>
                    <td>可以被同一个 Pod 内的多个容器<strong>共享</strong></td>
                </tr>
                <tr>
                    <td><strong>典型用途</strong></td>
                    <td>临时文件、程序运行时的垃圾</td>
                    <td>数据库文件、日志、配置文件</td>
                </tr>
            </tbody>
        </table>
    </section>

    <section id="chapter-4">
        <h2>四、动手实战：体验 K8S 的“自愈能力”</h2>
        <p>光说不练假把式。我们将通过一个真实的实验，亲手体验 K8S 是如何通过 YAML 管理应用，并在故障发生时自动修复的。</p>
        
        <div class="lab-card">
            <div class="lab-header">
                <span>🔬 实验：部署 Nginx 并验证自愈能力</span>
                <span class="status-badge beginner">入门</span>
            </div>
            <div class="lab-body">
                <div class="tip-box">
                    <span class="tip-title">实验目标</span>
            <ul class="checklist">
                <li>学会使用 <strong>YAML</strong> 文件部署应用（声明式）。</li>
                <li>亲手“杀掉”一个 Pod，观察 K8S 如何<strong>自动复活</strong>它。</li>
            </ul>
        </div>

        <h3>Step 1: 准备 YAML 文件</h3>
        <p>首先，我们需要创建一个描述文件，告诉 K8S 我们想要什么。将下面的内容保存为 <code>my-k8s-demo.yaml</code>，或者直接复制备用。</p>
        <p>这个 YAML 文件同时描述了两样东西：一个管理 3 个 Nginx 副本的 <strong>Deployment</strong>，和一个暴露端口的 <strong>Service</strong>。</p>
<pre class="yaml"><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-demo
spec:
  replicas: 3               # 【重点】我们要 3 个副本
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:alpine # 使用轻量级镜像
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx
  ports:
    - port: 80
      targetPort: 80
  type: NodePort
</code></pre>

        <h3>Step 2: 声明式部署 (Apply)</h3>
        <p>在 K8S 中，我们很少用命令去一个个创建，而是直接把 YAML 文件“甩”给 K8S。</p>
        <p>如果你在本地创建了文件，请运行 <code>kubectl apply -f my-k8s-demo.yaml</code>。</p>
        <p>如果没有文件，我们可以用下面这条命令直接通过命令行应用上面的配置：</p>

        <pre><code class="language-bash"># WSL 用户请复制这段运行
cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-demo
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:alpine
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx
  ports:
    - port: 80
      targetPort: 80
  type: NodePort
EOF</code></pre>
        <p><em>预期输出：<br>deployment.apps/nginx-demo created<br>service/nginx-service created</em></p>

        <h3>Step 3: 检查状态</h3>
        <p>看看 K8S 是否按照我们的要求，启动了 3 个 Pod。</p>
        <pre><code class="language-bash">kubectl get pods</code></pre>
        <p><em>预期输出：你应该能看到 3 个名字类似 <code>nginx-demo-xxxx-xxxx</code> 的 Pod，状态都是 <code>Running</code>。</em></p>

        <h3>Step 4: 破坏实验 (见证自愈)</h3>
        <p>现在，我们要扮演“捣乱者”。手动删除其中一个 Pod，看看会发生什么。</p>
        <p>1. 复制上面列表中任意一个 Pod 的名字。</p>
        <p>2. 运行删除命令：</p>
        <pre><code class="language-bash"># 请替换 <pod-name> 为你实际看到的 Pod 名字
kubectl delete pod <pod-name></code></pre>
        
        <p>3. <strong>立刻</strong>再次查看 Pod 列表：</p>
        <pre><code class="language-bash">kubectl get pods</code></pre>
        
        <div class="note-box">
            <strong>你发现了什么？</strong>
            <p>你会发现：</p>
            <ul class="checklist">
                <li>旧的 Pod 正在显示 <code>Terminating</code> (正在销毁)。</li>
                <li><strong>但是！</strong> 一个全新的 Pod 已经显示 <code>Running</code> 或 <code>ContainerCreating</code> 了，而且它的名字和旧的不一样。</li>
            </ul>
            <p><strong>这就是 K8S 的自愈能力！</strong> Deployment 发现少了一个副本（变成了 2/3），立刻启动了一个新的，强行把数量拉回了 3。</p>
        </div>

        <h3>Step 5: 一键清理</h3>
        <p>使用 YAML 的另一个好处是清理非常方便。我们不需要一个个删 Deployment 和 Service，只需要告诉 K8S：“把这个文件里定义的东西都删掉”。</p>
        <pre><code class="language-bash"># 如果你有文件
kubectl delete -f my-k8s-demo.yaml

# 或者直接按名称删除
kubectl delete deployment nginx-demo
kubectl delete service nginx-service</code></pre>
            </div>
        </div>
    </section>

    <section id="summary">
        <h2>五、本课小结</h2>
        
        <h3>一句话总结</h3>
        <p>K8S 就是一个<strong>自动化的大管家</strong>。你告诉它“我要什么”（声明式），它就负责指挥底下的“工人”（Node）去干活，并保证结果永远符合你的要求。</p>

        <h3>核心概念速记</h3>
        <table class="prop-table">
            <thead>
                <tr>
                    <th>概念</th>
                    <th>类比</th>
                    <th>作用</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Pod</strong></td>
                    <td>豌豆荚 / 最小工作组</td>
                    <td>K8S 调度的最小单位，包含一个或多个容器。</td>
                </tr>
                <tr>
                    <td><strong>Node</strong></td>
                    <td>工人 / 车间</td>
                    <td>实际运行 Pod 的机器。</td>
                </tr>
                <tr>
                    <td><strong>Deployment</strong></td>
                    <td>包工头 / 自动补货机</td>
                    <td>管理 Pod 的副本数量，负责滚动更新。</td>
                </tr>
                <tr>
                    <td><strong>Service</strong></td>
                    <td>前台 / 固定电话</td>
                    <td>提供稳定的访问入口，自动转发流量。</td>
                </tr>
            </tbody>
        </table>

        <!-- 下一课预告 -->
        <div class="note-box">
            <strong>下一课预告：</strong>
            <p>光说不练假把式。下一课我们将进行【K8S 实战操作】，我们将亲手写一个 YAML 文件，把一个网站部署到 K8S 里，并体验一下“拔掉网线”后 K8S 是如何自动修复的！</p>
        </div>
    </section>

</main>

</body>
</html>
